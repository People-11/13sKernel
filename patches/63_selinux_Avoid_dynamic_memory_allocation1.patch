From 7d2a04da7633a01b13d53f4709cbb3814efd7064 Mon Sep 17 00:00:00 2001
From: Sultan Alsawaf <sultan@kerneltoast.com>
Date: Sat, 27 May 2023 14:57:21 -0700
Subject: [PATCH] selinux: Avoid dynamic memory allocation for temporary
 scontext buffers

Common sizes for the scontext buffers are small enough to fit on the stack,
saving two dynamic memory allocations from this hot path.

Change-Id: I9bace557c9ed55cee5c27a29cde4d2c897242c96
Signed-off-by: Sultan Alsawaf <sultan@kerneltoast.com>
Signed-off-by: Richard Raya <rdxzv.dev@gmail.com>
---
 security/selinux/ss/services.c | 40 +++++++++++++++++++++++++---------
 1 file changed, 30 insertions(+), 10 deletions(-)

Index: common/security/selinux/ss/services.c
===================================================================
--- common/security/selinux/ss/services.c	2025-10-07 00:24:05.191724184 +1030
+++ common/security/selinux/ss/services.c	2025-10-07 00:24:05.191724184 +1030
@@ -1499,6 +1499,8 @@
 	struct selinux_policy *policy;
 	struct policydb *policydb;
 	struct sidtab *sidtab;
+	char scontext2_onstack[SZ_128] __aligned(sizeof(long));
+	char str_onstack[SZ_128] __aligned(sizeof(long));
 	char *scontext2, *str = NULL;
 	struct context context;
 	int rc = 0;
@@ -1508,9 +1510,15 @@
 		return -EINVAL;
 
 	/* Copy the string to allow changes and ensure a NUL terminator */
-	scontext2 = kmemdup_nul(scontext, scontext_len, gfp_flags);
-	if (!scontext2)
-		return -ENOMEM;
+	if (scontext_len < sizeof(scontext2_onstack)) {
+		scontext2 = scontext2_onstack;
+		memcpy(scontext2, scontext, scontext_len);
+		scontext2[scontext_len] = '\0';
+	} else {
+		scontext2 = kmemdup_nul(scontext, scontext_len, gfp_flags);
+		if (!scontext2)
+			return -ENOMEM;
+	}
 
 	if (!selinux_initialized()) {
 		u32 i;
@@ -1530,10 +1538,16 @@
 
 	if (force) {
 		/* Save another copy for storing in uninterpreted form */
-		rc = -ENOMEM;
-		str = kstrdup(scontext2, gfp_flags);
-		if (!str)
-			goto out;
+		if (scontext2 == scontext2_onstack) {
+			str = str_onstack;
+			memcpy(str, scontext2, scontext_len + 1);
+		} else {
+			str = kstrdup(scontext2, gfp_flags);
+			if (!str) {
+				rc = -ENOMEM;
+				goto out;
+			}
+		}
 	}
 retry:
 	rcu_read_lock();
@@ -1544,11 +1558,15 @@
 				      &context, def_sid);
 	if (rc == -EINVAL && force) {
 		context.str = str;
-		context.len = strlen(str) + 1;
+		context.len = scontext_len + 1;
 		str = NULL;
 	} else if (rc)
 		goto out_unlock;
 	rc = sidtab_context_to_sid(sidtab, &context, sid);
+
+	if (context.str == str_onstack)
+		context.str = NULL;
+
 	if (rc == -ESTALE) {
 		rcu_read_unlock();
 		if (context.str) {
@@ -1562,8 +1580,10 @@
 out_unlock:
 	rcu_read_unlock();
 out:
-	kfree(scontext2);
-	kfree(str);
+	if (scontext2 != scontext2_onstack) {
+		kfree(scontext2);
+		kfree(str);
+	}
 	return rc;
 }
 
