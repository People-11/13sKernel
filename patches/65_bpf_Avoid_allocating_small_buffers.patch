From 6b42119d1534155f368abc0698b9752f7841c922 Mon Sep 17 00:00:00 2001
From: Sultan Alsawaf <sultan@kerneltoast.com>
Date: Fri, 26 May 2023 21:43:45 -0700
Subject: [PATCH] bpf: Avoid allocating small buffers for map keys and values

Most, if not all, map keys and values are rather small and can fit on the
stack, eliminating the need to allocate them dynamically. Reserve some
small stack buffers for them to avoid dynamic memory allocation.

Signed-off-by: Sultan Alsawaf <sultan@kerneltoast.com>
---
 kernel/bpf/syscall.c | 162 ++++++++++++++++++++++++++++++++-----------
 1 file changed, 120 insertions(+), 42 deletions(-)

Index: common/kernel/bpf/syscall.c
===================================================================
--- common/kernel/bpf/syscall.c	2025-10-07 00:24:05.341724184 +1030
+++ common/kernel/bpf/syscall.c	2025-10-07 00:24:05.341724184 +1030
@@ -1437,6 +1437,8 @@
 	int ufd = attr->map_fd;
 	struct bpf_map *map;
 	void *key, *value;
+	u8 key_onstack[SZ_16] __aligned(sizeof(long));
+	u8 value_onstack[SZ_64] __aligned(sizeof(long));
 	u32 value_size;
 	struct fd f;
 	int err;
@@ -1462,18 +1464,30 @@
 		goto err_put;
 	}
 
-	key = __bpf_copy_key(ukey, map->key_size);
-	if (IS_ERR(key)) {
-		err = PTR_ERR(key);
-		goto err_put;
+	if (map->key_size && map->key_size <= sizeof(key_onstack)) {
+		key = key_onstack;
+		if (copy_from_user(key, ukey, map->key_size)) {
+			err = -EFAULT;
+			goto err_put;
+		}
+	} else {
+		key = __bpf_copy_key(ukey, map->key_size);
+		if (IS_ERR(key)) {
+			err = PTR_ERR(key);
+			goto err_put;
+		}
 	}
 
 	value_size = bpf_map_value_size(map);
 
 	err = -ENOMEM;
-	value = kvmalloc(value_size, GFP_USER | __GFP_NOWARN);
-	if (!value)
-		goto free_key;
+	if (value_size <= sizeof(value_onstack)) {
+		value = value_onstack;
+	} else {
+		value = kvmalloc(value_size, GFP_USER | __GFP_NOWARN);
+		if (!value)
+			goto free_key;
+	}
 
 	if (map->map_type == BPF_MAP_TYPE_BLOOM_FILTER) {
 		if (copy_from_user(value, uvalue, value_size))
@@ -1494,9 +1508,11 @@
 	err = 0;
 
 free_value:
-	kvfree(value);
+	if (value != value_onstack)
+		kvfree(value);
 free_key:
-	kvfree(key);
+	if (key != key_onstack)
+		kvfree(key);
 err_put:
 	fdput(f);
 	return err;
@@ -1512,6 +1528,8 @@
 	int ufd = attr->map_fd;
 	struct bpf_map *map;
 	void *key, *value;
+	u8 key_onstack[SZ_16] __aligned(sizeof(long));
+	u8 value_onstack[SZ_64] __aligned(sizeof(long));
 	u32 value_size;
 	struct fd f;
 	int err;
@@ -1535,24 +1553,42 @@
 		goto err_put;
 	}
 
-	key = ___bpf_copy_key(ukey, map->key_size);
-	if (IS_ERR(key)) {
-		err = PTR_ERR(key);
-		goto err_put;
+	if (map->key_size && map->key_size <= sizeof(key_onstack)) {
+		key = key_onstack;
+		if (copy_from_bpfptr(key, ukey, map->key_size)) {
+			err = -EFAULT;
+			goto err_put;
+		}
+	} else {
+		key = ___bpf_copy_key(ukey, map->key_size);
+		if (IS_ERR(key)) {
+			err = PTR_ERR(key);
+			goto err_put;
+		}
 	}
 
 	value_size = bpf_map_value_size(map);
-	value = kvmemdup_bpfptr(uvalue, value_size);
-	if (IS_ERR(value)) {
-		err = PTR_ERR(value);
-		goto free_key;
+	if (value_size <= sizeof(value_onstack)) {
+		value = value_onstack;
+		if (copy_from_bpfptr(value, uvalue, value_size)) {
+			err = -EFAULT;
+			goto free_key;
+		}
+	} else {
+		value = kvmemdup_bpfptr(uvalue, value_size);
+		if (IS_ERR(value)) {
+			err = PTR_ERR(value);
+			goto free_key;
+		}
 	}
 
 	err = bpf_map_update_value(map, f.file, key, value, attr->flags);
 
-	kvfree(value);
+	if (value != value_onstack)
+		kvfree(value);
 free_key:
-	kvfree(key);
+	if (key != key_onstack)
+		kvfree(key);
 err_put:
 	bpf_map_write_active_dec(map);
 	fdput(f);
@@ -1568,6 +1604,7 @@
 	struct bpf_map *map;
 	struct fd f;
 	void *key;
+	u8 key_onstack[SZ_16] __aligned(sizeof(long));
 	int err;
 
 	if (CHECK_ATTR(BPF_MAP_DELETE_ELEM))
@@ -1583,10 +1620,18 @@
 		goto err_put;
 	}
 
-	key = ___bpf_copy_key(ukey, map->key_size);
-	if (IS_ERR(key)) {
-		err = PTR_ERR(key);
-		goto err_put;
+	if (map->key_size && map->key_size <= sizeof(key_onstack)) {
+		key = key_onstack;
+		if (copy_from_bpfptr(key, ukey, map->key_size)) {
+			err = -EFAULT;
+			goto err_put;
+		}
+	} else {
+		key = ___bpf_copy_key(ukey, map->key_size);
+		if (IS_ERR(key)) {
+			err = PTR_ERR(key);
+			goto err_put;
+		}
 	}
 
 	if (bpf_map_is_offloaded(map)) {
@@ -1606,7 +1651,8 @@
 	bpf_enable_instrumentation();
 	maybe_wait_bpf_programs(map);
 out:
-	kvfree(key);
+	if (key != key_onstack)
+		kvfree(key);
 err_put:
 	bpf_map_write_active_dec(map);
 	fdput(f);
@@ -1623,6 +1669,8 @@
 	int ufd = attr->map_fd;
 	struct bpf_map *map;
 	void *key, *next_key;
+	u8 key_onstack[SZ_16] __aligned(sizeof(long));
+	u8 next_key_onstack[SZ_64] __aligned(sizeof(long));
 	struct fd f;
 	int err;
 
@@ -1639,19 +1687,31 @@
 	}
 
 	if (ukey) {
-		key = __bpf_copy_key(ukey, map->key_size);
-		if (IS_ERR(key)) {
-			err = PTR_ERR(key);
-			goto err_put;
+		if (map->key_size && map->key_size <= sizeof(key_onstack)) {
+			key = key_onstack;
+			if (copy_from_user(key, ukey, map->key_size)) {
+				err = -EFAULT;
+				goto err_put;
+			}
+		} else {
+			key = __bpf_copy_key(ukey, map->key_size);
+			if (IS_ERR(key)) {
+				err = PTR_ERR(key);
+				goto err_put;
+			}
 		}
 	} else {
 		key = NULL;
 	}
 
 	err = -ENOMEM;
-	next_key = kvmalloc(map->key_size, GFP_USER);
-	if (!next_key)
+	if (map->key_size <= sizeof(next_key_onstack)) {
+		next_key = next_key_onstack;
+	} else {
+		next_key = kvmalloc(map->key_size, GFP_USER);
+		if (!next_key)
 		goto free_key;
+	}
 
 	if (bpf_map_is_offloaded(map)) {
 		err = bpf_map_offload_get_next_key(map, key, next_key);
@@ -1672,9 +1732,11 @@
 	err = 0;
 
 free_next_key:
-	kvfree(next_key);
+	if (next_key != next_key_onstack)
+		kvfree(next_key);
 free_key:
-	kvfree(key);
+	if (key != key_onstack)
+		kvfree(key);
 err_put:
 	fdput(f);
 	return err;
@@ -1908,6 +1970,8 @@
 	int ufd = attr->map_fd;
 	struct bpf_map *map;
 	void *key, *value;
+	u8 key_onstack[SZ_16] __aligned(sizeof(long));
+	u8 value_onstack[SZ_64] __aligned(sizeof(long));
 	u32 value_size;
 	struct fd f;
 	int err;
@@ -1942,18 +2006,30 @@
 		goto err_put;
 	}
 
-	key = __bpf_copy_key(ukey, map->key_size);
-	if (IS_ERR(key)) {
-		err = PTR_ERR(key);
-		goto err_put;
+	if (map->key_size && map->key_size <= sizeof(key_onstack)) {
+		key = key_onstack;
+		if (copy_from_user(key, ukey, map->key_size)) {
+			err = -EFAULT;
+			goto err_put;
+		}
+	} else {
+		key = __bpf_copy_key(ukey, map->key_size);
+		if (IS_ERR(key)) {
+			err = PTR_ERR(key);
+			goto err_put;
+		}
 	}
 
 	value_size = bpf_map_value_size(map);
 
-	err = -ENOMEM;
-	value = kvmalloc(value_size, GFP_USER | __GFP_NOWARN);
-	if (!value)
-		goto free_key;
+	if (value_size <= sizeof(value_onstack)) {
+		value = value_onstack;
+	} else {
+		err = -ENOMEM;
+		value = kvmalloc(value_size, GFP_USER | __GFP_NOWARN);
+		if (!value)
+			goto free_key;
+	}
 
 	err = -ENOTSUPP;
 	if (map->map_type == BPF_MAP_TYPE_QUEUE ||
@@ -1983,9 +2059,11 @@
 	err = 0;
 
 free_value:
-	kvfree(value);
+	if (value != value_onstack)
+		kvfree(value);
 free_key:
-	kvfree(key);
+	if (key != key_onstack)
+		kvfree(key);
 err_put:
 	bpf_map_write_active_dec(map);
 	fdput(f);
